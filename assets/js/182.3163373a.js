(window.webpackJsonp=window.webpackJsonp||[]).push([[182],{515:function(v,_,e){"use strict";e.r(_);var o=e(4),c=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"go语言的csp模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#go语言的csp模型"}},[v._v("#")]),v._v(" "),_("code",[v._v("Go")]),v._v("语言的"),_("code",[v._v("CSP")]),v._v("模型")]),v._v(" "),_("p",[_("code",[v._v("go")]),v._v("语言的最大两大亮点,一个是"),_("code",[v._v("goroutine")]),v._v(",一个就是"),_("code",[v._v("chan")]),v._v("了.二者合体的典型应用"),_("code",[v._v("CSP")]),v._v(",基本就是并行开发神器,简化了并行程序的开发难度.")]),v._v(" "),_("h4",{attrs:{id:"一、csp是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、csp是什么"}},[v._v("#")]),v._v(" 一、"),_("code",[v._v("CSP")]),v._v("是什么")]),v._v(" "),_("p",[_("code",[v._v("CSP")]),v._v("是"),_("code",[v._v("Communicating Sequential Process")]),v._v("的简称,中文可以叫做通信顺序进程,是一种并发编程模型,是一个很强大的并发数据模型,是上世纪七十年代提出的,用于描述两个独立的并发实体通过共享的通讯"),_("code",[v._v("channel")]),v._v("(管道)进行通信的并发模型.相对于"),_("code",[v._v("Actor")]),v._v("模型,"),_("code",[v._v("CSP")]),v._v("中"),_("code",[v._v("channel")]),v._v("是第一类对象,它不关注发送消息的实体,而关注与发送消息时使用的"),_("code",[v._v("channel")]),v._v(".")]),v._v(" "),_("p",[v._v("严格来说,"),_("code",[v._v("CSP")]),v._v("是一门形式语言(类似于"),_("img",{attrs:{src:"https://bruce-log-img.oss-cn-shanghai.aliyuncs.com/image-20221125135958550.png",alt:"image-20221125135958550"}}),_("code",[v._v("calculus")]),v._v("),用于描述并发系统中的互动模式,也因此称为一众面向并发的编程语言的理论源头,并衍生了"),_("code",[v._v("Occam/Limbo/Golang...")])]),v._v(" "),_("p",[v._v("而具体到编程语言,如"),_("code",[v._v("Golang")]),v._v(",其实只用到了"),_("code",[v._v("CSP")]),v._v("的很小一部分,即理论中的"),_("code",[v._v("Proccess/Channel")]),v._v("(对应到语言中的"),_("code",[v._v("goroutine/channel")]),v._v("): 这两个并发原语之间没有从属关系,"),_("code",[v._v("Process")]),v._v("可以订阅任意个"),_("code",[v._v("Channel")]),v._v(","),_("code",[v._v("Channel")]),v._v("也并不关心是哪个"),_("code",[v._v("Process")]),v._v("在利用它进行通信;"),_("code",[v._v("Process")]),v._v("围绕"),_("code",[v._v("Channel")]),v._v("进行读写,形成一套有序阻塞和可预测的并发模型.")]),v._v(" "),_("h4",{attrs:{id:"二、golang-csp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、golang-csp"}},[v._v("#")]),v._v(" 二、"),_("code",[v._v("Golang CSP")])]),v._v(" "),_("p",[v._v("与主流语言通过共享内存来进行并发控制方式不同,"),_("code",[v._v("Go")]),v._v("语言采用了"),_("code",[v._v("CSP")]),v._v("模式,这是一种用于描述两个独立的并发实体通过共享的通讯"),_("code",[v._v("Channel")]),v._v("(管道)进行通信的并发模型.")]),v._v(" "),_("p",[_("code",[v._v("Golang")]),v._v("就是借用"),_("code",[v._v("CSP")]),v._v("模型的一些概念为之前实现并发进行理论支持,其实从实际上出发,"),_("code",[v._v("go")]),v._v("语言并没有,完全实现了"),_("code",[v._v("CSP")]),v._v("模型的所有理论,仅仅是借用了"),_("code",[v._v("process")]),v._v("和"),_("code",[v._v("channel")]),v._v("这两个概念."),_("code",[v._v("process")]),v._v("是在"),_("code",[v._v("go")]),v._v("语言上的表现就是"),_("code",[v._v("goroutine")]),v._v("是实际并发执行的实体,每个实体之间是通过"),_("code",[v._v("channel")]),v._v("通讯来实现数据共享.")]),v._v(" "),_("p",[_("code",[v._v("Go")]),v._v("语言的"),_("code",[v._v("CSP")]),v._v("模型是由协程"),_("code",[v._v("Goroutine")]),v._v("与通道"),_("code",[v._v("Channel")]),v._v("实现:")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Go")]),v._v("协程"),_("code",[v._v("goroutine")]),v._v(": 是一种轻量线程,它不是操作系统的线程,而是将一个操作系统线程分段使用,通过调度器实现协作式调度.是一种绿色线程,微线程,它于"),_("code",[v._v("Coroutine")]),v._v("协程也有区别,能够在发现阻塞后启动新的微线程.")]),v._v(" "),_("li",[v._v("通道"),_("code",[v._v("channel")]),v._v(": 类似"),_("code",[v._v("Unix")]),v._v("的"),_("code",[v._v("Pipe")]),v._v(",用于协程之间通讯和同步.协程之前虽然解耦,但是他们和"),_("code",[v._v("Channel")]),v._v("有着耦合.")])]),v._v(" "),_("h4",{attrs:{id:"三、channel"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、channel"}},[v._v("#")]),v._v(" 三、"),_("code",[v._v("Channel")])]),v._v(" "),_("p",[_("code",[v._v("Goroutine")]),v._v("和"),_("code",[v._v("channel")]),v._v("是"),_("code",[v._v("Go")]),v._v("语言并发编程的两个基石."),_("code",[v._v("Goroutine")]),v._v("用于执行并发任务,"),_("code",[v._v("channel")]),v._v("用于"),_("code",[v._v("goroutine")]),v._v("之间的同步、通道.")]),v._v(" "),_("p",[_("code",[v._v("Channel")]),v._v("在"),_("code",[v._v("goroutine")]),v._v("间架起了一条管道,在管道里传输数据,实现"),_("code",[v._v("goroutine")]),v._v("间的通信;由于它是线程安全的,所以用起来非常方便;"),_("code",[v._v("channel")]),v._v('还提供"先进先出"的特性;它还能影响'),_("code",[v._v("goroutine")]),v._v("的阻塞和唤醒.")]),v._v(" "),_("blockquote",[_("p",[v._v("不要通过共享内存来通信,而要通过通信来实现内存共享.")]),v._v(" "),_("p",[_("code",[v._v("Do not communicate by sharing memory,instead,share memory by communicating.")])])]),v._v(" "),_("p",[v._v("这就是"),_("code",[v._v("Go")]),v._v("的并发哲学,它依赖"),_("code",[v._v("CSP")]),v._v("模型,基于"),_("code",[v._v("channel")]),v._v("实现.")]),v._v(" "),_("h5",{attrs:{id:"channel实现csp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#channel实现csp"}},[v._v("#")]),v._v(" "),_("code",[v._v("channel")]),v._v("实现"),_("code",[v._v("CSP")])]),v._v(" "),_("p",[_("code",[v._v("Channel")]),v._v("是"),_("code",[v._v("Go")]),v._v("语言中一个非常重要的类型,是"),_("code",[v._v("Go")]),v._v("里的第一对象.通过"),_("code",[v._v("channel")]),v._v(","),_("code",[v._v("Go")]),v._v("实现了通过通信来实现内存共享."),_("code",[v._v("Channel")]),v._v("是在多个"),_("code",[v._v("goroutine")]),v._v("之间传递数据和同步的重要手段.")]),v._v(" "),_("p",[v._v("使用原子函数、读写锁可以保证资源的共享访问安全,但使用"),_("code",[v._v("channel")]),v._v("更优雅.")]),v._v(" "),_("p",[_("code",[v._v("channel")]),v._v('字面意义是"通道",类似于'),_("code",[v._v("Linux")]),v._v("中的管道.说明"),_("code",[v._v("channel")]),v._v("的语法如下:")]),v._v(" "),_("div",{staticClass:"language-go line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-go"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("chan")]),v._v(" T "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//声明一个双向通道")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("chan")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<-")]),v._v("  "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//声明一个只能用于发送的通道")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<-")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("chan")]),v._v(" T "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//声明一个只能用于接收的通道")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br")])]),_("p",[v._v("单向通道的声明,用"),_("code",[v._v("<-")]),v._v("来表示,它指明通道的方向.只要明白,代码的书写顺序是从左到右就马上掌握通道的方向是怎样的.")]),v._v(" "),_("p",[v._v("因为"),_("code",[v._v("channel")]),v._v("是一个引用类型,所以在它被初始化之前,它的值是"),_("code",[v._v("nil , channel")]),v._v("使用"),_("code",[v._v("make")]),v._v("函数进行初始化.可以向它传递一个"),_("code",[v._v("int")]),v._v("值,代表"),_("code",[v._v("channel")]),v._v("缓冲区的大小(容量),构造出来的 是一个缓冲性的"),_("code",[v._v("channel")]),v._v(": 不传或传"),_("code",[v._v("0")]),v._v("的,构造的就是一个非缓冲性的"),_("code",[v._v("channel")]),v._v(".")]),v._v(" "),_("p",[v._v("两者有一些差别: 非缓冲型"),_("code",[v._v("channel")]),v._v('无法缓冲元素,对它的操作一定顺序是"发送->接收->发送->接收->....",如果想连续向一个非缓冲'),_("code",[v._v("chan")]),v._v("发送2个元素,并且没有接收的话,第一次一定会被阻塞;对于缓冲型"),_("code",[v._v("channel")]),v._v('的操作,则要"宽松"一些,毕竟是带了"缓冲"光环.')]),v._v(" "),_("p",[_("img",{attrs:{src:"https://bruce-log-img.oss-cn-shanghai.aliyuncs.com/image-20221125144205052.png",alt:"image-20221125144205052"}})]),v._v(" "),_("p",[v._v("对"),_("code",[v._v("chan")]),v._v("的发送和接收操作都会在编译期间转换成为底层的发送接收函数.")]),v._v(" "),_("p",[_("code",[v._v("Channel")]),v._v("分为两种: 带缓冲、不带缓冲.怼不带缓冲的"),_("code",[v._v("channel")]),v._v('进行的操作实际上可以看作"同步模式",带缓冲的则称为"异步模式".')]),v._v(" "),_("p",[v._v("同步模式下,发送方和接收方要同步就绪,只有在两者都"),_("code",[v._v("ready")]),v._v("的情况下,数据才能在两者之间传输(后面会看到,实际上就是内存拷贝).否则,任意一方先进行发送或接收操作,都会被挂起,等另一方的出现才能被唤醒.")]),v._v(" "),_("p",[v._v("异步模式下,在缓冲槽可用的情况下(有剩余容量),发送和接收操作都可以顺利进行.否则,操作的一方(如写入)同样会被挂起,知道出现相反操作(如接收)才会被唤醒.")]),v._v(" "),_("p",[v._v("小结: 同步模式下,必须要使发送方和接收方配对,操作才会成功,否则会被阻塞;异步模式下,缓冲槽要有剩余容量,操作才能成功,否则也会被阻塞.")]),v._v(" "),_("p",[v._v("简单来说,"),_("code",[v._v("CSP")]),v._v("模型由并发执行的实体(线程或者进程或者协程)所组成,实体之间通过发送消息进行通信,这里发送消息时使用的就是通道,或者叫"),_("code",[v._v("channel")]),v._v(".")]),v._v(" "),_("p",[_("code",[v._v("CSP")]),v._v("模型的关键是关注"),_("code",[v._v("channel")]),v._v(",而不是关注发送消息的实体."),_("code",[v._v("Go")]),v._v("语言实现了"),_("code",[v._v("CSP")]),v._v("部分理论,"),_("code",[v._v("goroutine")]),v._v("对应"),_("code",[v._v("CSP")]),v._v("中并发执行的实体,"),_("code",[v._v("channel")]),v._v("也就对应着"),_("code",[v._v("CSP")]),v._v("中的"),_("code",[v._v("channel")]),v._v(".")]),v._v(" "),_("h4",{attrs:{id:"四、goroutine"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、goroutine"}},[v._v("#")]),v._v(" 四、"),_("code",[v._v("Goroutine")])]),v._v(" "),_("p",[_("code",[v._v("Goroutine")]),v._v("是实际并发执行的实体,它底层使用协程("),_("code",[v._v("coroutine")]),v._v(")实现并发,"),_("code",[v._v("coroutine")]),v._v("是一种运行在用户态的用户线程,类似于"),_("code",[v._v("greenthread")]),v._v(","),_("code",[v._v("go")]),v._v("底层选择使用"),_("code",[v._v("coroutine")]),v._v("的出发点是因为,它具有如下特点:")]),v._v(" "),_("ul",[_("li",[v._v("用户空间避免了内核态和用户态的切换导致的成本")]),v._v(" "),_("li",[v._v("可以由语言和框架层进行调度")]),v._v(" "),_("li",[v._v("更小的栈空间允许创建大量的实例")])]),v._v(" "),_("p",[v._v("可以看到第二条 用户空间线程的调度不是由操作系统来完成的,像在"),_("code",[v._v("java 1.3")]),v._v("中使用的"),_("code",[v._v("grennthread")]),v._v("的是由"),_("code",[v._v("JVM")]),v._v("统一调度的(后"),_("code",[v._v("java")]),v._v(")已经改为内核线程,还有"),_("code",[v._v("ruby")]),v._v("中的"),_("code",[v._v("fiber")]),v._v("(半协程)是需要重新中自己进行调度的,而"),_("code",[v._v("goroutine")]),v._v("是在"),_("code",[v._v("golang")]),v._v("层面提供了调度器,并且对网络"),_("code",[v._v("IO")]),v._v("库进行了封装,屏蔽了复杂的细节,对外提供统一的语法关键字支持,简化了并发程序编写的成本.")]),v._v(" "),_("h4",{attrs:{id:"五、goroutine调度器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、goroutine调度器"}},[v._v("#")]),v._v(" 五、"),_("code",[v._v("Goroutine")]),v._v("调度器")]),v._v(" "),_("p",[_("code",[v._v("Go")]),v._v("并发调度: "),_("code",[v._v("G-P-M")]),v._v("模型")]),v._v(" "),_("p",[v._v("在操作系统提供的内核线程之上,"),_("code",[v._v("Go")]),v._v("搭建了一个特有的两级线程模型."),_("code",[v._v("goroutine")]),v._v("机制实现了"),_("code",[v._v("M: N")]),v._v("的线程模型,"),_("code",[v._v("goroutine")]),v._v("机制是线程"),_("code",[v._v("（coroutine）")]),v._v("的一种实现,"),_("code",[v._v("golang")]),v._v("内置的调度器,可以让多核"),_("code",[v._v("CPU")]),v._v("中每个"),_("code",[v._v("CPU")]),v._v("执行一个协程.")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://bruce-log-img.oss-cn-shanghai.aliyuncs.com/image-20221125150737980.png",alt:"image-20221125150737980"}})]),v._v(" "),_("h4",{attrs:{id:"六、总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#六、总结"}},[v._v("#")]),v._v(" 六、总结")]),v._v(" "),_("p",[_("code",[v._v("Golang")]),v._v("的"),_("code",[v._v("channel")]),v._v("将"),_("code",[v._v("goroutine")]),v._v("隔离开,并发编程的时候可以将注意力放在"),_("code",[v._v("channel")]),v._v("上.在一定程度上,这个和消息队列的解耦功能还是挺像的.上面主要介绍了一些"),_("code",[v._v("channel")]),v._v("的常规操作.")]),v._v(" "),_("p",[_("code",[v._v("Go")]),v._v("通过"),_("code",[v._v("channel")]),v._v("和"),_("code",[v._v("goroutine")]),v._v("之后,"),_("code",[v._v("Go")]),v._v("的并发编程变得异常容易和安全,得以让程序员把注意力留到业务上去,实现开发效率的提升.")]),v._v(" "),_("p",[v._v("要知道,技术并不最重要的,它只是实现业务的工具.一门高效的开发语言可以把节省下来的时间,留着去做更多有意义的事情.")]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("CSP")]),v._v("最早是由"),_("code",[v._v("Tony Hoare")]),v._v("在"),_("code",[v._v("1977")]),v._v("年提出,据说至今这个理论模型还是更新,")]),v._v(" "),_("p",[v._v("查阅电子版本: "),_("code",[v._v("http://www.usingcsp.com/cspbook.pdf")]),v._v(".")])])])}),[],!1,null,null,null);_.default=c.exports}}]);